#### Арифметические операторы

#### Запись чисел

В современном JavaScript существует два типа чисел:
1. Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers). Это числа, которые мы будем использовать чаще всего.
2. BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются в случаях, когда необходимо работать со значениями более чем 2e53 или менее чем -2e53. Сейчас это отдельный тип данных

Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой.

Арифметические операции для чисел, например, умножение *, деление /, сложение +, вычитание - и деление по модулю (получение остатка от деления) %

Более сложные математические действия используют объект Math.

**Integer Literals / целочисленный литерал**

Когда число находится прямо в программе JavaScript, оно называется числовым литералом. Любой числовой литерал может предваряться знаком минус (-), чтобы делать число отрицательным.
```javascript
// целочисленные литералы в десятичном виде
0
3
1000000000
// целочисленные литералы в шестнадцатеричном виде
0xff
// целочисленные литералы в форме восьмеричном виде
Oo377
// целочисленные литералы в двоичном виде
0b10101
```
**Floating-Point Literals / числовые литералы с плавающей точкой:**

могут содержать десятичную точку; они используют традиционный синтаксис для вещественных чисел. Вещественное значение представляется как целая часть числа, за которой следует десятичная точка и дробная часть числа. Числовые литералы с плавающей точкой также могут быть представлены в экспоненциальной записи: вещественное число, за которым следует буква е (или Е), необязательный знак плюс или минус и целочисленный показатель степени (экспонента). Такая запись представляет вещественное число, умноженное на 10 в степени экспоненты.

```javascript
3.14
2345.6789
.333333333
6.02e23 // 6.02 x 10 в 23-й степени

let biilion = 1_000_000_000; // такая запись внедрена в браузерах и Node, но не в стандарт JS
```
**Специальные числовые значения**
 Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.
Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.
 Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.
```javascript
// Мы можем получить его в результате деления на ноль:
alert( 1 / 0 ); // Infinity

// Или задать его явно:
alert( Infinity ); // Infinity
```
 NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
```javascript
alert( "не число" / 2 ); // NaN,
// такое деление является ошибкой

// Значение NaN «прилипчиво».
// Любая операция с NaN возвращает NaN:

alert( "не число" / 2 + 5 ); // NaN
```
В JavaScript тип «number» не может содержать числа больше, чем (2e53-1) (т. е. 9007199254740991), или меньше, чем -(2e53-1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.

**Способы записи чисел**
```javascript
let billion = 1000000000;
let billion = 1e9; // 1 миллиард, буквально: 1 и 9 нулей
alert(7.3e9);  // 7.3 миллиардов (7,300,000,000)
let ms = 0.000001;
let ms = 1e-6; // шесть нулей, слева от 1
// SIС!!!
> let billion = 1e9;
undefined
> billion
1000000000
```
**Шестнадцатеричные, двоичные и восьмеричные числа**
Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x, после которого указывается число.
Например:
```javascript
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
```
Не так часто используются двоичные и восьмеричные числа, но они также поддерживаются 0b для двоичных и 0o для восьмеричных:
```javascript
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
alert( a == b ); // true, с двух сторон число 255
```
Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию parseInt.

**toString(base)**

```javascript
let num = 255;
alert( num.toString(16) );  // ff
alert( 255..toString(16) );  // ff .. это SIC!!
alert( num.toString(2) );   // 11111111
alert( 123456..toString(36) ); // 2n9c;
```

#### Фишка JS: неточные вычисления
Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведён на хранение знака.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:
`alert( 1e500 ); // Infinity`
Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.Посмотрите на это (неверное!) сравнение:

`alert( 0.1 + 0.2 == 0.3 ); // false`
Да-да, сумма 0.1 и 0.2 не равна 0.3.
Странно! Что тогда, если не 0.3?
`alert( 0.1 + 0.2 ); // 0.30000000000000004`

Ой! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют заказ из 2-х позиций за $0.10 и $0.20. Итоговый заказ будет $0.30000000000000004. Это будет сюрпризом для всех.

Но почему это происходит?

Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.

Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3).

Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет. По той же причине и в двоичной системе счисления, деление на 2 обязательно сработает, а 1/10 становится бесконечной дробью.

В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.
Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

Пример:
`alert( 0.1.toFixed(20) ); // 0.10000000000000000555`

И когда мы суммируем 2 числа, их «неточности» тоже суммируются.

Вот почему 0.1 + 0.2 – это не совсем 0.3.Не только в JavaScript
Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.

Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):

```javascript
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```
Помните, что метод toFixed всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. Также это удобно для форматирования цен в интернет-магазине $0.30. В других случаях можно использовать унарный оператор +, чтобы преобразовать строку в число:

```javascript
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```
Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она все равно появляется при финальном делении:

```javascript
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```
Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.

Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. Но что будет, если мы применим скидку 30%? На практике у нас не получится полностью избавиться от дроби. Просто используйте округление, чтобы отрезать «хвосты», когда надо.Забавный пример

Попробуйте выполнить его:
```javascript
// Привет! Я – число, растущее само по себе!
alert( 9999999999999999 ); // покажет 10000000000000000
```

Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».Два нуля

Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0.

Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.
В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.

#### Фишка JS: безопасность математических операций

Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.

Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.

#### Math. Математические действия-

В дополнение к базовым арифметическим операциям JavaScript поддерживает более сложные математические действия через набор функций и констант, определенных как свойства объекта Math:

```javascript
Math.pow(2,53) // => 9007199254740992: 2 to the power
53
Math.round(.6) // => 1.0: round to the nearest integer
Math.ceil(.6) // => 1.0: round up to an integer
Math.floor(.6) // => 0.0: round down to an integer
Math.abs(-5) // => 5: absolute value
Math.max(x,y,z) // Return the largest argument
Math.min(x,y,z) // Return the smallest argument
Math.random() // Pseudo-random number x where 0 <= x< 1.0
Math.PI // π: circumference of a circle /
diameter
Math.E // e: The base of the natural logarithm
Math.sqrt(3) // => 3**0.5: the square root of 3
Math.pow(3, 1/3) // => 3**(1/3): the cube root of 3
Math.sin(0) // Trigonometry: also Math.cos,
Math.atan, etc.
Math.log(10) // Natural logarithm of 10
Math.log(100)/Math.LN10 // Base 10 logarithm of 100
Math.log(512)/Math.LN2 // Base 2 logarithm of 512
Math.exp(3) // Math.E cubed

//В ES6 определены дополнительные функции объекта Math:

Math.pow(2,53) // => 9007199254740992: 2 to the power
53
Math.round(.6) // => 1.0: round to the nearest integer
Math.ceil(.6) // => 1.0: round up to an integer
Math.floor(.6) // => 0.0: round down to an integer
Math.abs(-5) // => 5: absolute value
Math.max(x,y,z) // Return the largest argument
Math.min(x,y,z) // Return the smallest argument
Math.random() // Pseudo-random number x where 0 <= x< 1.0
Math.PI // π: circumference of a circle /
diameter
Math.E // e: The base of the natural logarithm
Math.sqrt(3) // => 3**0.5: the square root of 3
Math.pow(3, 1/3) // => 3**(1/3): the cube root of 3
Math.sin(0) // Trigonometry: also Math.cos,
Math.atan, etc.
Math.log(10) // Natural logarithm of 10
Math.log(100)/Math.LN10 // Base 10 logarithm of 100
Math.log(512)/Math.LN2 // Base 2 logarithm of 512
Math.exp(3) // Math.E cubed
```

#### Математика и JS
[Базовая математика в JavaScript — числа и операторы](https://developer.mozilla.org/ru/docs/Learn/JavaScript/First_steps/Math)
[Математика в JavaScript](https://habr.com/ru/post/312880/)
[Базовые операторы, математика](https://learn.javascript.ru/operators)
[JavaScript Essentials: числа и математика](https://medium.com/nuances-of-programming/javascript-essentials-%D1%87%D0%B8%D1%81%D0%BB%D0%B0-%D0%B8-%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0-ccf6b582a79)
[Математики в шоке: в JavaScript происходит такое!](https://proglib.io/p/wtf-javascript-math)
