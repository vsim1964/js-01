Динамическая типизация и ее реализация с помощью преобразования типов есть та изюминка JS, которая раздражает одних и восхищает других. По всей видимости, она обязана своим появлением тому, что браузерами пользуются не только профессиональные программисты и ввод данных в браузере сопряжен с различными пониманиями введенного.
![](../%2300%20%D0%9B%D0%B8%D0%BD%D0%B3%D0%B2%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0/img/04.png)
![](../%2300%20%D0%9B%D0%B8%D0%BD%D0%B3%D0%B2%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0/img/05.png)

**parseInt и parseFloat**
Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:
`alert( +"100px" ); // NaN`
Единственное исключение — это пробелы в начале строки и в конце, они игнорируются.
В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например "100px" или "12pt" в CSS. Также во множестве стран символ валюты записывается после номинала "19€". Так как нам получить числовое значение из таких строк?

Для этого есть parseInt и parseFloat.

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:
```javascript
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```

Второй аргумент parseInt(str, radix)

Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:
```javascript
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает

alert( parseInt('2n9c', 36) ); // 123456
```
**Явные и неявные преобразования**
Если интерпретатор JavaScript пожелает иметь строку, тогда любое переданное вами значение будет преобразовано в строку. Если интерпретатор JavaScript желает число, то попробует преобразовать предоставленное вами значение в число (или в NaN, когда осмысленное преобразование невозможно).
```javascript
> '7' + '4'
'74'
> '7' * '4'
28
> '7' / '4'
1.75
> '7' - '4'
3
> '7' % '4'
3
```
**Явные преобразования**
Простейший способ выполнения явных преобразований типов предусматривает применение функций Boolean (), Number () и  Strin g ():
```javascript
N umber("3") // => 3
String(false) // => "false": либо используйте false.toString()
Boolean([]) // => true
```
Любое значение кроме null и undefined имеет метод to String(), результат которого обычно будет таким же, как возвращаемый функцией  String().
Неявные преобразования
Определенные операции JavaScript выполняют неявное преобразование типов и временами используются явно в целях преобразования типов. Если одним операндом операции + является строка, тогда другой операнд преобразуется в строку. Унарная операция + преобразует свой операнд в число. У
